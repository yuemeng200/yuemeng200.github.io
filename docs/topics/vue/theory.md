# 第 4 章 进入 vue 原理

## 1、响应式原理

### (1) 对象的变化侦测

> 下文提到的`状态`指数据单元。是`data`中定义的一个对象，同时也是对象里的每一个属性。

实现响应式的关键在于把所有数据及其属性变为可被侦测的，即在`get`和`set`时能被监测到，对于每一个状态通过`Observer`类来实现变化侦测，使用其`walk()`递归遍历对象的所有层级，通过`defineReactive()`调用`Object.defineProperty()`来实现侦测效果。对于每一个状态，有唯一的`Dept`用来管理其所有的依赖，之后在`get`时收集依赖，在`set`时通知依赖更新。这个依赖是什么呢？可能是一段`template`或者一个`watch`等，无论什么东西我们都用一个`Watcher`实例来代理，于是在状态发生变化时通知这个代理即可，由其再去触发生成新的`虚拟dom`，通过对比新旧虚拟 dom，最小化更新真实 dom。

> 在`vue 1.x`时使用的是细粒度的变化侦测，即依赖细化到每一个节点，此时根本不需要虚拟 dom 和 diff 的参与，因为已经足够知道需要更新哪些 dom。但事实证明这种管理依赖的方法效率很低，因为太复杂。
> 从`vue 2.x`开始使用中粒度的变化侦测，依赖只细化到使用该状态的组件，组件内部自己去检查发生了究竟要更新哪部分 dom。这样看起来繁琐了一些，但事实证明采取这种策略效率提升了非常多。你可能会疑惑状态就是在组件中声明的呀，只收集这个组件还有啥意义。状态的确是在组件中声明的，从一个组件实例也很容易找到他的所有状态，但从一个状态找到所有使用它的组件并不容易，状态并不是只在声明它的组件中使用！

### (2) 数组的变化侦测

数组本身的变化侦测和对象有差异，因为我们使用方法来改变数组元素。为了不污染全局`Array.prototype`，只对需要变化侦测的数组使用拦截器作为`__proto__`来覆盖原型方法，对于不支持`__proto__`的浏览器，直接遍历拦截器的方法设置即可。

:::warning 注意
> 响应式发挥作用的前提只针对`data`中初始存在的数据。同时对于给对象添加、删除属性以及给数组元素赋新值也无法触发`set`，因为在`ES6`之前，js 没有提供可以侦测到这种变化的`元编程`的能力。此时需要`Vue.set(obj, property/index, value)`和`Vue.delete()`手动加入响应式系统。

另外，当给已经添加到响应式系统的状态赋值新对象时，新对象的所有属性会被重新添加进响应式，重新走一趟依赖收集的过程，这也能解决上面的问题，为了简便可以使用`this.obj = Object.assign({}, this.obj, {...})`。
:::


![原理图](https://cn.vuejs.org/images/data.png)

## 2、虚拟 dom

> 原生 html+js 的前端页面也是有状态的，页面中使用的数据即是状态，当我们想要改变状态时，需要手动去更改使用这些状态的 dom，因为 dom 和状态是没有依赖关系的。然而必须要明白一点，引入虚拟 dom 并没有真正优化操作 dom 的效率，只是在不想手动操作 domn 的场景下，引入虚拟 dom 这个中间层能带给程序一些细粒度的更新提示，不然只能完全重新渲染页面了。

虚拟 dom 是层次结构的`VNode`，它是个描述了如何去生成真实 dom 的节点描述对象。至少包含`tag`、`attrs`和`children`属性。


具体实现是：模板被编译为 render 函数（涉及编译原理），该 render 函数就能在需要时生成当前模板对应的虚拟 dom，进而转化为真实 dom 树并在页面渲染出来。当状态发生变化时，通知所有依赖重新 render 出虚拟 dom，此时 vue 并不会把新生成的虚拟 dom 立即重新渲染出页面来，因为通过虚拟 dom 重新转化为真实 dom 本身也是个复杂的过程。因为 dom 树的属性太多，再者重新渲染整个 dom 到页面也是耗时的。所以 vue 的真实做法是对新旧 dom 进行细粒度的 diff，找出最小差异，然后只根据这些差异去修改 dom 树，此时性能就提升了。
所以说虚拟 dom 其实是为了更好地 diff。

值得注意的是并不是在每次状态变化都会立即在页面响应变化，而是将当前更新添加到异步更新队列，在循环周期结束后统一进行dom更新操作。但这种机制在有些场景下会带来不便，比如我们在状态更新后想要立即通过`ref`获取dom信息，此时的dom还并没有更新，可以使用`Vue.nextTick(callback)`来防止错误，注意这里的`callback`是挂载到实例上执行的，同时是个异步操作。所以说我们并没有强制让dom立即更新，而只是为下次更新埋下个回调。

## 3、Diff 算法

diff 出两个虚拟 dom 的差异，然后根据差异信息修改真实 dom 节点，这整个过程称为`patch`。即使用 js 的计算成本去换取 DOM 的操作成本。
`patchs = patch(oldVNode, newVNode)`
其实`patchs`就是得到的接下来的`dom操作`。
基本过程如下：使用`isSameVNode()`判断两节点是否值得比较（key && tag && type），不直接比较直接`replace`，相同的话进行`patchVNode()`打补丁操作，如果有一方没有子节点直接增删，如果都是文本节点直接修改，如果都有子节点就麻烦了，需要执行`updateChildren()`操作，即递归地怕把对子节点进行`patch()`，首先想到的是对于任一`newVNodeChildren`，去所有`oldVNodeChildren`中进行`isSameVNode`，这种方案的时间复杂度是`O(mn)`，效率很低。
改进方案如下：

- 双指针法，两边向中间收拢。
- 命中策略依次为新前和旧前、新后和旧后、新后和旧前、新前与旧后。
- 不命中执行全局循环。
