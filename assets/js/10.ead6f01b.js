(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{408:function(t,_,v){"use strict";v.r(_);var s=v(56),a=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"正则表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[t._v("#")]),t._v(" 正则表达式")]),t._v(" "),v("h2",{attrs:{id:"_1、介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、介绍"}},[t._v("#")]),t._v(" 1、介绍")]),t._v(" "),v("p",[v("code",[t._v("正则表达式")]),t._v("可以看做是一种用来描述字符串"),v("code",[t._v("模式匹配")]),t._v("规则的协议，通过遵循这种协议的语义，我们向正则解析引擎描述自己需要找出什么样的子串。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("正则表达式的底层实现原理十分复杂（事实上就是仅仅学会正则的用法都不能算是简单的事情），但可以肯定的一点是，正则模式匹配的平均效率一定比所有你能想到的模型匹配算法要高效得多，所以 "),v("strong",[t._v("Just use it！")])])]),t._v(" "),v("h2",{attrs:{id:"_2、体验"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、体验"}},[t._v("#")]),t._v(" 2、体验")]),t._v(" "),v("p",[t._v("前端验证密码复杂性是正则表达式十分重要的使用场景，我们直接从一个实际问题上手，验证用户设置的密码必须满足以下规则：")]),t._v(" "),v("ul",[v("li",[t._v("同时包含数字、大小写字母和特殊字符。")]),t._v(" "),v("li",[t._v("长度不低于8位。")])]),t._v(" "),v("p",[t._v("在表单验证场景下，这算比较基础的问题，但时如果不使用正则而纯粹手写验证逻辑却几乎难以下手。\n下面直接给出我想到的一种正则模式："),v("strong",[v("code",[t._v("^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^\\da-zA-Z\\s]).{8,}$")])]),t._v("。\n现在看不懂没关系，毕竟我也刚学会，但我保证你看完后面的章节能和我一样牛逼。")]),t._v(" "),v("p",[t._v("顺便先说下有了正则表达式应该怎么去使用，正则表达式本身在各种语言是通用的，只是调用的"),v("code",[t._v("api")]),t._v("略有差异。\n在JS中直接通过字面量（"),v("code",[t._v("/我是正则/")]),t._v("）或者使用构造函数（"),v("code",[t._v('new RegExp("我是正则")')]),t._v("）两种方式定义都可以，比如上面验证密码的可以封装到一个函数里：")]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("check")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("password")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" re "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token regex"}},[v("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")]),v("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[t._v("^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^\\da-zA-Z\\s]).{8,}$")]),v("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")])]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" re"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("password"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也可以使用 password.match(re)来验证，没有差别。")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("check")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1Password.'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("一般情况下建议不要使用"),v("code",[t._v("new RegExp()")]),t._v("传入字符串的方式来声明正则对象，因为正则里有太多使用"),v("code",[t._v("\\")]),t._v("作为前缀的转义字符表示，而字符串本身也有转义符号，且两者根本不兼容。举个栗子，"),v("code",[t._v("\\s")]),t._v("在正则里用来匹配空白字符（包括空格、tab、换行），如果我们写成"),v("code",[t._v('new RegExp("\\s")')]),t._v("，js引擎会直接当作我们写的是"),v("code",[t._v('new RegExp("s")')]),t._v("，因为字符串里根本没有"),v("code",[t._v("\\s")]),t._v("这种转义，所以直接就帮我们删掉了，那怎么解决呢？就是必须再转义一次写成"),v("code",[t._v('new RegExp("\\\\s")')]),t._v("，当转义较多时这样很容易出错，而使用字面量的方式直接用"),v("code",[t._v("/\\s/")]),t._v("就行了。")])]),t._v(" "),v("h2",{attrs:{id:"_3、基本使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、基本使用"}},[t._v("#")]),t._v(" 3、基本使用")]),t._v(" "),v("h3",{attrs:{id:"_1-普通字符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-普通字符"}},[t._v("#")]),t._v(" (1) 普通字符")]),t._v(" "),v("p",[t._v("一个普通字符单元用来匹配"),v("code",[t._v("一个")]),t._v("真实的字符。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("表示")]),t._v(" "),v("th",[t._v("描述")]),t._v(" "),v("th",[t._v("模式举例")]),t._v(" "),v("th",[t._v("匹配结果")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("[ABC]")]),t._v(" "),v("td",[t._v("匹配 [...] 中任一字符")]),t._v(" "),v("td",[t._v("[123]k")]),t._v(" "),v("td",[t._v("12"),v("code",[t._v("3k")])])]),t._v(" "),v("tr",[v("td",[t._v("[^ABC]")]),t._v(" "),v("td",[t._v("匹配 [...] 以外的任一字符")]),t._v(" "),v("td",[t._v("[123]k")]),t._v(" "),v("td",[t._v("123k"),v("code",[t._v("4k")])])]),t._v(" "),v("tr",[v("td",[t._v("[A-Z]")]),t._v(" "),v("td",[t._v("匹配区间A-Z中任一字符")]),t._v(" "),v("td",[t._v("[A-Z]2")]),t._v(" "),v("td",[t._v("A"),v("code",[t._v("B2")]),t._v("C")])]),t._v(" "),v("tr",[v("td",[t._v(".")]),t._v(" "),v("td",[t._v("匹配除了换行和回车以外的任一字符")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("\\s")]),t._v(" "),v("td",[t._v("匹配任一空白符")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("\\S")]),t._v(" "),v("td",[t._v("匹配任一非空白符")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("\\w")]),t._v(" "),v("td",[t._v("匹配任一字母、数字或下划线，等价于[0-9a-zA-Z_]")]),t._v(" "),v("td"),t._v(" "),v("td")])])]),t._v(" "),v("h3",{attrs:{id:"_2-限定符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-限定符"}},[t._v("#")]),t._v(" (2) 限定符")]),t._v(" "),v("p",[t._v("限定符用于限制前面字符单元（字符或表达式）出现的次数。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("表示")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("?")]),t._v(" "),v("td",[t._v("修饰前面的表达式出现0次或1次")])]),t._v(" "),v("tr",[v("td",[t._v("+")]),t._v(" "),v("td",[t._v("修饰前面的表达式出现1次或多次")])]),t._v(" "),v("tr",[v("td",[t._v("*")]),t._v(" "),v("td",[t._v("修饰前面的表达式出现任意次")])]),t._v(" "),v("tr",[v("td",[t._v("{}")]),t._v(" "),v("td",[t._v("匹配次数限定符")])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[v("code",[t._v("+")]),t._v("和"),v("code",[t._v("*")]),t._v("默认开启贪婪匹配，在其用添加"),v("code",[t._v("?")]),t._v("可开启非贪婪模式。")])]),t._v(" "),v("h3",{attrs:{id:"_3-定位符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-定位符"}},[t._v("#")]),t._v(" (3) 定位符")]),t._v(" "),v("p",[t._v("定位符本身不匹配真实的字符，而是限制匹配的开始和结束位置。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("表示")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("^")]),t._v(" "),v("td",[t._v("匹配输入字符串开始的位置")])]),t._v(" "),v("tr",[v("td",[t._v("$")]),t._v(" "),v("td",[t._v("匹配输入字符串结尾的位置")])]),t._v(" "),v("tr",[v("td",[t._v("\\b")]),t._v(" "),v("td",[t._v("匹配一个单词边界，即字与空格间的位置。")])]),t._v(" "),v("tr",[v("td",[t._v("\\B")]),t._v(" "),v("td",[t._v("匹配非单词边界")])])])]),t._v(" "),v("h3",{attrs:{id:"_4-其他符号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-其他符号"}},[t._v("#")]),t._v(" (4) 其他符号")]),t._v(" "),v("p",[t._v("| 表示 | 描述                                                   |\n| ()   | 用来包裹一个表达式，同时可以捕获该表达式方便在后面使用 |\n| []   | 是区间限定符，但也有其他用途                           |")])])}),[],!1,null,null,null);_.default=a.exports}}]);