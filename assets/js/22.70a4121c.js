(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{434:function(t,v,_){"use strict";_.r(v);var l=_(56),e=Object(l.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"第-7-章-回溯"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第-7-章-回溯"}},[t._v("#")]),t._v(" 第 7 章 回溯")]),t._v(" "),_("p",[_("code",[t._v("回溯法")]),t._v("是纯暴力算法，之所以用是因为非用不可，普通的 for 循环无法描述的问题。主要针对以下问题：")]),t._v(" "),_("ul",[_("li",[t._v("排列组合")]),t._v(" "),_("li",[t._v("子集生成")]),t._v(" "),_("li",[t._v("切割问题")]),t._v(" "),_("li",[t._v("棋盘问题")])]),t._v(" "),_("p",[t._v("关于回溯的特征：")]),t._v(" "),_("ul",[_("li",[t._v("所有回溯法都可以抽象为"),_("code",[t._v("树形结构")])]),t._v(" "),_("li",[t._v("回溯算法用来解决 n 重循环问题")]),t._v(" "),_("li",[t._v("回溯函数一般没有返回值")]),t._v(" "),_("li",[t._v("回溯树的深度是即原来 for 的层数，节点的宽度表示可选的状态，用 for 循环表示")])])])}),[],!1,null,null,null);v.default=e.exports}}]);