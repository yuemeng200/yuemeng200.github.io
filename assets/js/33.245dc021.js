(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{441:function(e,_,v){"use strict";v.r(_);var d=v(56),o=Object(d.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"第4章-进入vue原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第4章-进入vue原理"}},[e._v("#")]),e._v(" 第4章 进入vue原理")]),e._v(" "),v("h2",{attrs:{id:"_1、响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、响应式原理"}},[e._v("#")]),e._v(" 1、响应式原理")]),e._v(" "),v("h3",{attrs:{id:"_1-对象的变化侦测"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-对象的变化侦测"}},[e._v("#")]),e._v(" (1) 对象的变化侦测")]),e._v(" "),v("blockquote",[v("p",[e._v("下文提到的"),v("code",[e._v("状态")]),e._v("指数据单元。是"),v("code",[e._v("data")]),e._v("中定义的一个对象，同时也是对象里的每一个属性。\n实现响应式的关键在于把所有数据及其属性变为可被侦测的，即在"),v("code",[e._v("get")]),e._v("和"),v("code",[e._v("set")]),e._v("时能被监测到，对于每一个状态通过"),v("code",[e._v("Observer")]),e._v("类来实现变化侦测，使用其"),v("code",[e._v("walk()")]),e._v("递归遍历对象的所有层级，通过"),v("code",[e._v("defineReactive()")]),e._v("调用"),v("code",[e._v("Object.defineProperty()")]),e._v("来实现侦测效果。对于每一个状态，有唯一的"),v("code",[e._v("Dept")]),e._v("用来管理其所有的依赖，之后在"),v("code",[e._v("get")]),e._v("时收集依赖，在"),v("code",[e._v("set")]),e._v("时通知依赖更新。这个依赖是什么呢？可能是一段"),v("code",[e._v("template")]),e._v("或者一个"),v("code",[e._v("watch")]),e._v("等，无论什么东西我们都用一个"),v("code",[e._v("Watcher")]),e._v("实例来代理，于是在状态发生变化时通知这个代理即可，由其再去触发生成新的"),v("code",[e._v("虚拟dom")]),e._v("，通过对比新旧虚拟dom，最小化更新真实dom。\n在"),v("code",[e._v("vue 1.x")]),e._v("时使用的是细粒度的变化侦测，即依赖细化到每一个节点，此时根本不需要虚拟dom和diff的参与，因为已经足够知道需要更新哪些dom。但事实证明这种管理依赖的方法效率很低，因为太复杂。\n从"),v("code",[e._v("vue 2.x")]),e._v("开始使用中粒度的变化侦测，依赖只细化到使用该状态的组件，组件内部自己去检查发生了究竟要更新哪部分dom。这样看起来繁琐了一些，但事实证明采取这种策略效率提升了非常多。你可能会疑惑状态就是在组件中声明的呀，只收集这个组件还有啥意义。状态的确是在组件中声明的，从一个组件实例也很容易找到他的所有状态，但从一个状态找到所有使用它的组件并不容易，状态并不是只在声明它的组件中使用！")])]),e._v(" "),v("h3",{attrs:{id:"_2-数组的变化侦测"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-数组的变化侦测"}},[e._v("#")]),e._v(" (2) 数组的变化侦测")]),e._v(" "),v("p",[e._v("数组本身的变化侦测和对象有差异，因为我们使用方法来改变数组元素。为了不污染全局"),v("code",[e._v("Array.prototype")]),e._v("，只对需要变化侦测的数组使用拦截器作为"),v("code",[e._v("__proto__")]),e._v("来覆盖原型方法，对于不支持"),v("code",[e._v("__proto__")]),e._v("的浏览器，直接遍历拦截器的方法设置即可。")]),e._v(" "),v("h3",{attrs:{id:"_3-vm-watch的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-vm-watch的实现"}},[e._v("#")]),e._v(" (3) vm.$watch的实现")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://weread.qq.com/web/reader/f8632810723f0231f86d9aakd3d322001ad3d9446802347",target:"_blank",rel:"noopener noreferrer"}},[e._v("待看"),v("OutboundLink")],1)]),e._v(" "),v("blockquote",[v("p",[e._v("响应式发挥作用的前提只针对"),v("code",[e._v("data")]),e._v("中初始存在的数据。同时对于给对象添加、删除属性以及给数组元素赋新值也无法触发"),v("code",[e._v("set")]),e._v("，因为在"),v("code",[e._v("ES6")]),e._v("之前，js没有提供可以侦测到这种变化的"),v("code",[e._v("元编程")]),e._v("的能力。此时需要"),v("code",[e._v("Vue.set(obj, property/index, value)")]),e._v("和"),v("code",[e._v("Vue.delete()")]),e._v("手动加入响应式系统。\n"),v("a",{attrs:{href:"https://cn.vuejs.org/images/data.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("原理图"),v("OutboundLink")],1)])]),e._v(" "),v("h2",{attrs:{id:"_2、虚拟dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、虚拟dom"}},[e._v("#")]),e._v(" 2、虚拟dom")]),e._v(" "),v("blockquote",[v("p",[e._v("原生html+js的前端页面也是有状态的，页面中使用的数据即是状态，当我们想要改变状态时，需要手动去更改使用这些状态的dom，因为dom和状态是没有依赖关系的。然而必须要明白一点，引入虚拟dom并没有真正优化操作dom的效率，只是在不想手动操作domn的场景下，引入虚拟dom这个中间层能带给程序一些细粒度的更新提示，不然只能完全重新渲染页面了。\n虚拟dom是层次结构的"),v("code",[e._v("VNode")]),e._v("，它是个描述了如何去生成真实dom的节点描述对象。\n具体实现是：模板被编译为render函数（涉及编译原理），该render函数就能在需要时生成当前模板对应的虚拟dom，进而转化为真实dom树并在页面渲染出来。当状态发生变化时，通知所有依赖重新render出虚拟dom，此时vue并不会把新生成的虚拟dom立即重新渲染出页面来，因为通过虚拟dom重新转化为真实dom本身也是个复杂的过程。因为dom树的属性太多，再者重新渲染整个dom到页面也是耗时的。所以vue的真实做法是对新旧dom进行细粒度的diff，找出最小差异，然后只根据这些差异去修改dom树，此时性能就提升了。\n所以说虚拟dom其实是为了更好地diff。")])]),e._v(" "),v("h2",{attrs:{id:"_3、diff算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、diff算法"}},[e._v("#")]),e._v(" 3、Diff算法")]),e._v(" "),v("p",[e._v("diff出两个虚拟dom的差异，然后修改真实dom节点，这整个过程称为"),v("code",[e._v("patch")]),e._v("。即使用js的计算成本去换取DOM的操作成本。\n"),v("code",[e._v("patchs = patch(oldVNode, newVNode)")]),e._v("\n其实"),v("code",[e._v("patchs")]),e._v("就是得到的接下来的"),v("code",[e._v("dom操作")]),e._v("。\n基本过程如下：新旧树逐层对比，先看节点类型，不同直接替换（删除旧的），相同再看属性是否要更新，之后递归diff过程。\n显然任何dom树都能抽象为一个一维的结构，所以按照顺序依次比较两个"),v("code",[e._v("VNode")]),e._v("是能够得到修改方案，但这种粗暴的方案是非常低效的，尤其在涉及到增删dom时。\ndiff优化的策略坚持一下几个原则：")]),e._v(" "),v("ul",[v("li",[e._v("同层比较，永不跨层")]),e._v(" "),v("li",[e._v("双指针法，两边向中间收拢。")]),e._v(" "),v("li",[e._v("关键在于 key。")]),e._v(" "),v("li",[e._v("命中策略依次为新前和旧前、新后和旧后、新后和旧前、新前与旧后。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);